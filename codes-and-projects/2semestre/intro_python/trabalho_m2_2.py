# -*- coding: utf-8 -*-
"""TrabM2.2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xnbviQZGxNVvY1bQitRmA52mv8J5cjLe

O objetivo do trabalho da M2.2 é trabalhar com esteganografia em imagens. Dada uma imagem, devem ser implementados os algoritmos para esconder uma mensagem e para ler uma mensagem escondida.

Essa mensagem deve ser escondida no último bit da cor vermelha (não precisa trabalhar com binários, somente com valores pares e ímpares) e deve ser retirada uma mensagem de lá.

Precisam ser criadas duas funções: uma que crie uma lista de inteiros (com valores de 0 ou 1) composta pelos últimos dígitos da cor vermelha da imagem; a outra função dever receber uma lista de inteiros como parâmetro e alterar o último bit da cor vermelha da imagem para cada elemento. Lembre-se que a lista não vai ser grande o suficiente para toda a imagem, então altere a imagem só até a mensagem terminar.

Não precisam se preocupar com a conversão da mensagem de texto para a lista de bits e nem o contrário, abaixo já existem essas duas funções prontas: `gerar_mensagem()` recebe uma string por parâmetro e gera uma lista de inteiros e `converter_mensagem()` recebe uma lista de inteiros e gera uma mensagem.

**O trabalho deve utilizar essas duas funções, para o trabalho feito sem elas será atribuída nota 0.**
"""

import numpy as np
import cv2 as cv
from google.colab.patches import cv2_imshow

def bitfield(n):
    return [int(digit) for digit in bin(n)[2:]]

def gerar_mensagem(mensagem):
    lista = []
    for m in mensagem:
        val = ord(m)
        bits = bitfield(val)

        if len(bits) < 8:
            for a in range(8-len(bits)):
                bits.insert(0,0)
        lista.append(bits)
    arr = np.array(lista)
    arr = arr.flatten()
    return arr

def converter_mensagem(saida):
    bits = np.array(saida)
    mensagem_out = ''
    bits = bits.reshape((int(len(saida)/8), 8))
    for b in bits:
        sum = 0
        for i in range(8):
            sum += b[i]*(2**(7-i))
        mensagem_out += chr(sum)
    return mensagem_out

#Código desenvolvido por Gabriel Bósio, Gustavo Baron Lauritzen e Matheus Baron Lauritzen

#Pega os valores vermelhos da imagem
def guardar_valores_vermelhos(img):
    img_red = []
    #Guardando os valores vermelhos da imagem da primeira 'linha' de pixels
    for i, V in enumerate(img[0,:,2]): 
        img_red.append(bitfield(V)[-1])
    return img_red

#Escreve mensagem na imagem
def escrever_msg(img, msg):
    #Guarda os valores vermelhos da imagem
    img_red = img[:,:,2]
    #Verifica se o tamanho da mensagem é menor que a largura da imagem
    if len(msg) < len(img_red[0]): 
        for i, V in enumerate(img_red[0]):
            #Verifica se a mensagem foi escrita até o final
            if i < len(msg): 
                #"Escrevendo" mensagem
                binV = bin(V)
                binV = binV[0:-1] + str(msg[i])
                img_red[0][i] = int(binV, 2)
            else:
                break
        print("Valores vermelhos da imagem modificados com a mensagem:")
        print(img_red)
        #Colocando os valores vermelhos modificados com a mensagem nos valores vermelhos originais da imagem
        img[:,:,2] = img_red
    return img

img = cv.imread("goku.png")

print("Valores vermelhos da primeira linha de pixel da imagem(sem mensagem):")
imgV = guardar_valores_vermelhos(img)
print(imgV, end="\n\n")

msg_original = "Isso não é uma mensagem"
msg_original_bin = gerar_mensagem(msg_original)

img_convertida = escrever_msg(img, msg_original_bin)

print("Imagem(sem mensagem):")
cv2_imshow(img)

print("Imagem(com mensagem):")
cv2_imshow(img_convertida)

print("Valores vermelhos da primeira linha de pixel da imagem(com mensagem):")
img_convertida = guardar_valores_vermelhos(img)
print(img_convertida, end="\n\n")

print("Mensagem Original:", msg_original)
msg_convertida = converter_mensagem(img_convertida)
print("Mensagem Convertida:", msg_convertida)