# -*- coding: utf-8 -*-
"""FuncoesEDicionarios.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QTaAoSO0HUtriXg4A5AvThsrS3YShjPK

# Funções

---

### Estrutura

---

As funções são blocos de códigos, definidos por um nome, com o intuito de organizar o código e permitir a reutilização do mesmo.

A função é definida por uma linha de cabeçalho que começa com a palavra-chave `def` e termina com `:`, parecido com laços de repetição e desvios condicionais que já vimos. A estrutura é a seguinte:

```
def <nome>(<parametro>, <parametro>, ...): 
  <comando>
  <comando>
  ...
```

Com a diferença da necessidade da definição de um nome para a chamada e a presença de parâmetros. Primeiro vamos ver um exemplo simples:
"""

def ola_mundo():
  print("Ola Mundo")

"""Nada aconteceu, essa é a definição da função, ela não é executada, somente definida, para executar o seu conteúdo devemos chamar a função pelo seu nome."""

def ola():
  print("Ola")

  print("Mundo")

ola()
ola()
ola()

"""Isso mostra um pouco da estrutura do próprio Google Collaboratory, onde todos os blocos de execução estão interligados. (execute o primeiro, depois o segundo, depois o primeiro novamente)"""

y = 10

def olha():
  print("Olha")

"""### Parâmetros

---

As funções nomeadas são boas porque, uma vez definidas e entendemos o que fazem, podemos nos referir a elas pelo nome e não pensar muito no que fazem. 

Com os parâmetros, as funções são ainda mais poderosas, porque podem fazer praticamente a mesma coisa em cada chamada, mas não exatamente a mesma coisa. 

Os parâmetros podem fazer com que eles façam algo um pouco diferente. Os parâmetros são definidos dentro dos parênteses do cabeçalho da função, separados por vírgula, e devem ser definidos quando a função é invocada.
"""

def ola(nome):
  print("Boa noite,", nome)
  
ola("Rodrigo")
ola("Pedro")
ola("Alisson")

def media(n1, n2, n3):
  media = n1 + n2 + n3
  media = media / 3
  print("A mídia é", media)
  if media >= 7:
    print("Aprovado")

media(3, 4, 5)
media(10, 10, 10)
media(8, 7, 7)

"""### Retorno

---

Não apenas você pode passar um valor de parâmetro para uma função, mas também pode produzir um valor. Você já viu isso em algumas funções anteriores que você usou. 

Por exemplo, `len` usa uma lista ou string como um valor de parâmetro e retorna um número, o comprimento dessa lista ou sequência. `range` pega um número inteiro como um valor de parâmetro e retorna uma lista contendo todos os números de 0 até esse valor de parâmetro. Para retornar uma valor para a função, utilizamos o comando `return` seguido da variável que queremos retornar. A chamada de `return` finaliza a execução, independente do que venha depois.
"""

def media(n1, n2, n3):
  result = n1 + n2 + n3
  result = result / 3
  return result
  print("nunca vai executar essa linha")

#m = 5.33333
m = media(5, 5, 6)
print("A média é", m)

print("A média é", media(2, 3, 3))

#bool is_primo(int numero){
#    for(int i = 2; i < numero; i++){
#        if(numero % i == 0){
#            return false;
#        }
#    }
#
#    return true;
#}

def is_primo_teste(numero):
  for i in range(2, numero):
    if numero % i == 0:
      return False
  
  return True

def is_primo_escrita(numero):
  for i in range(2, numero):
    if numero % i == 0:
      return "Não é primo"
  
  return "É primo"

'''
print(is_primo_teste(45567))
print(is_primo_teste(3))
print(is_primo_teste(4))
print(is_primo_teste(9))
print(is_primo_teste(8))
print(is_primo_teste(45))
print(is_primo_teste(455))
'''

def media(n1, n2, n3):
  soma = n1 + n2 + n3
  m = soma / 3
  if m >= 7:
    return m, True
  else:
    return m, False

nota, aprovado = media(9, 7)

print("A nota foi", nota)
if aprovado == True:
  print("Aprovado")

def is_primo(numero):
  for i in range(2, numero):
    if numero % i == 0:
      return False, "Não é primo"
  
  return True, "É primo"

valor = int(input("Digite um valor:"))

teste = is_primo(valor)

print(teste)

_ , texto = is_primo(valor)

print(texto)

tupla = (15, 2, 4)
a, b, c = tupla
print(a)
print(b)
print(c)

a = 10
b = 15
a, b = b, a
print(a)
print(b)

lista = ["Pão", "Leite", "Ovo", "Azeite", "Sal"]

print(lista)
for item in lista:
  print("O item é", item)

print()

print(list(range(len(lista))))
for i in range(len(lista)):
  print("O item", i+1, "é", lista[i])

print()


print(list(enumerate(lista)))
for i, item in enumerate(lista):
  print("O item", i+1, "é", item)

"""### Escopo

---

Uma instrução de atribuição em uma função cria uma variável local. Para a variável no lado esquerdo do operador de atribuição, os parâmetros também são locais. É chamado local porque essa variável existe apenas dentro da função e você não pode usá-la fora.
"""

def soma(x, y): 
  s = x + y 
  return s 

top = soma(5, 2) 
print(top) 
print(y)#essa linha gera um erro

"""A modificação dos valores dentro das funções também não afeta os parâmetros."""

y = 10

def funcao(x):
  y = x + 1
  print("dentro", y)

print(y)
funcao(y)
print(y)

"""Para listas e outros tipos de dados mutáveis o funcionamento é um pouco diferente, mas falaremos melhor disso mais tarde."""

def funcao(vetor):
  vetor[1] = 5

vetor = [2, 3]
print(vetor)
funcao(vetor)
print(vetor)

def funcao(vetor):
  vetor[0] = 1

vetor = [2, 3]
print(vetor)
funcao(vetor)
print(vetor)

"""### Parâmetros Opcionais

---

No tratamento de funções até agora, cada definição de função especifica zero ou mais parâmetros formais e cada invocação de função fornece exatamente esses valores. Às vezes, é conveniente ter parâmetros opcionais que podem ser especificados ou omitidos. Quando um parâmetro opcional é omitido de uma chamada de função, o parâmetro formal é vinculado à um valor padrão. Quando o parâmetro opcional é incluído, o parâmetro formal é vinculado ao valor fornecido.

Os parâmetros opcionais são convenientes quando uma função é quase sempre usada de uma maneira simples, mas é bom permitir que seja usada de uma maneira mais complexa, com valores não padrão especificados para os parâmetros opcionais.
"""

valor = "100"
valor = int(valor, 2)
print(valor + 10)

n = input("Digite um valor:")

print(int(n, 16))

n = input("Digite um valor:")

print(int(n, 10))

print(int(n, 2)) #converte na base binária

"""
Ao definir uma função, você pode especificar um valor padrão para um parâmetro. Esse parâmetro se torna um parâmetro opcional quando a função é chamada. A maneira de especificar um valor padrão é com uma instrução de atribuição dentro da lista de parâmetros."""

def teste(n1, n2 = 0, n3 = 0, mult = 1):
    resultado = (n1 + n2 + n3) * mult
    print(resultado)

teste(2, n2=3, mult=4)

def soma(n1, n2 = 0, n3 = 0, n4 = 0):
  return n1 + n2 + n3 + n4

print(soma(2))
print(soma(2, 3, 5))

print("Legal")
print("O valor é", 2)
print(1, 3, 5, 1, 1, 1, 3, sep="")

print("Olha", end=" ")
print("que", end=" ")
print("legal")
print()

lista = ["A", "B", "C", "D", "E", "F"]

for item in lista:
  print(item, end=" ")



dia = 15
mes = 3
ano = 2025
print(dia, mes, ano)
print(dia, mes, ano, sep="/")

def imprimir_data(dia, mes, ano):
  print(dia, mes, ano, sep=":")

imprimir_data(25, 12, 2012)
imprimir_data(ano=2022, dia=12, mes=11)

"""Nos parâmetros opcionais, podemos definir valores padrão para parâmetros formais, o que tornou opcional fornecer valores para esses parâmetros ao chamar as funções, mas existe mais uma maneira de chamar funções com parâmetros opcionais, com a passagem de parâmetros com base em palavras-chave. 

Isso é particularmente conveniente quando existem vários parâmetros opcionais e você deseja fornecer um valor para um dos parâmetros posteriores sem fornecer um valor para os parâmetros anteriores.

A ideia básica de passar argumentos por palavra-chave é muito simples. Ao invocar uma função, entre parênteses sempre há 0 ou mais valores, separados por vírgulas. Com argumentos de palavra-chave, alguns dos valores podem estar no formato `nome = valor` em vez de apenas `valor`. 

Observe que quando você possui `nome = valor` em uma definição de função, ele define o valor padrão para um parâmetro quando nenhum valor é fornecido na chamada; quando você tem `nome = valor` na chamada, ele está fornecendo um valor, substituindo o padrão para esse parâmetro.
"""

def f(x = 2, y = 3, z = 40): 
  print("x, y, z, são: ", x, y, z) 

f()  
f(2) 
f(2, 5) 

f(2, z=10)

f(y = 8, x = 3)
f(z = 10)

#f(x = 3, 5) #essa linha gera erro, podemos ter mistura de parâmetros posicionais e de palavra-chave, mas os posicionais devem aparecer primeiro

for i in range(6):
  print(i)

"""# Dicionários

---

### Estrutura

---

Os tipos de dados compostos que estudamos em detalhes até agora - strings e listas - são coleções sequenciais. Isso significa que os itens da coleção são ordenados da esquerda para a direita e usam números inteiros como índices para acessar os valores que contêm. Isso também significa que, para procurar um valor específico, é necessário varrer os vários itens da lista até encontrar o valor desejado.

Às vezes, os dados podem ser organizados de forma mais útil, associando uma chave ao valor que estamos procurando. Por exemplo, se você for solicitado o número da página para o início do capítulo 5 em um livro grande, você poderá folhear o livro procurando o cabeçalho do capítulo 5. Se o número do capítulo aparecer no cabeçalho ou rodapé de cada página, você poderá encontrar o número da página rapidamente, mas geralmente é mais fácil e rápido ir para a página de índice e ver que o capítulo 5 começa na página 78.

Esse tipo de pesquisa direta de um valor no Python é feita com um objeto chamado Dicionário. Os dicionários são um tipo diferente de coleção. Eles são o tipo de mapeamento interno do Python. Um mapa é uma coleção associativa não ordenada. 

A associação, ou mapeamento, é de uma chave, que pode ser de qualquer tipo imutável (por exemplo, o nome e o número do capítulo na analogia acima), até um valor (o número da página inicial), que pode ser qualquer objeto de dados Python.
"""

logico = True
inteiro = 10
real = 1.2
strings = "asdas"
listas = [1, 2, 3, 4]
listas[0] = 2
listas[1] = 3
tuplas = ()
dicionario = {}

dicionario = {(1, 2, 2): [1, 2, 2], 'arroz': 4.58, True: 1.54, 'gasolina': 85.75, True: 23.54}
print(dicionario)
lista = ["one", "two", "three", "tree"]

print(lista[2])
print(lista[-1])

print(dicionario[(1, 2, 2)])
print(dicionario[True])

x = 2
x = 10

pt2en = {} 
print(pt2en)
pt2en["um"] = "one" 
print(pt2en)
pt2en["dois"] = "two" 
pt2en["tres"] = "three"
pt2en["arvore"] = "tree" 




print(pt2en)
print()
print(pt2en["dois"])
print(pt2en["arvore"])

"""Não importa em que ordem escrevemos os pares. Os valores em um dicionário são acessados com chaves, não com índices, portanto, não há necessidade de se preocupar com a ordem. 

Outra maneira de criar um dicionário é fornecer vários pares de valores-chave usando a mesma sintaxe da saída anterior.
"""

pt2en = {'um': 'one', 'dois': 'two', 'tres': 'three'} 
pt2en['um'] = "a"  
print(pt2en)

legal = {}
legal["a"] = 32
legal[2] = "batata"
legal[2] = "outro valor"
legal[(0, 1, True)] = [1, True, "w", 13, 31123, 4]

print(legal)

print(legal["a"])
print(legal[2])
print(legal[(0, 1, True)])

"""### Métodos Úteis

---

A instrução `del` remove um par de valor-chave de um dicionário. Por exemplo, o dicionário a seguir contém os nomes de várias frutas e o número de cada fruta em estoque. Se alguém comprar todas as peras, podemos remover a entrada do dicionário.
"""

estoque = {'uvas': 430, 'bananas': 312, 'laranjas': 525, 'peras': 217} 
print(estoque)
#del estoque['bananas']
estoque.pop('bananas')
print(estoque)
#del estoque['uvas']
estoque.pop('uvas')
print(estoque)

estoque["goiaba"] = 150
print(estoque)
estoque["peras"] = 250
print(estoque)

"""A função `len` também funciona em dicionários, retorna o número de pares de valor-chave."""

estoque = {'uvas': 430, 'bananas': 312, 'laranjas': 525, 'peras': 217} 
print(estoque)
print(list(estoque.keys()))
print(list(estoque.values()))
print(list(estoque.items()))

for chave in estoque.keys(): 
  print("A chave", chave, "mapeia o valor", estoque[chave]) 

lista = (1, 3, 45, 5, 6)
print(list(enumerate(lista)))

for indice in range(len(lista)):
  print("O índice", indice, "mapeia o valor", lista[indice])

for indice, valor in enumerate(lista):
  print("O índice", indice, "mapeia o valor", valor)

print(len(estoque))
del estoque['uvas']
print(len(estoque))

lista = (1, 3, 45, 5, 6)
print(len(lista))

for item in lista:
  print(item)

for item in estoque:
  print(item)

"""A função `keys` retorna uma visão das chaves do dicionário."""

lista = ['uvas', 'bananas', 'laranjas', 'peras']

for i in range(len(lista)):
  print("O indice", i, "mapeia o valor", lista[i]) 

print()

estoque = {'uvas': 430, 'bananas': 312, 'laranjas': 525, 'peras': 217} 

for chave in estoque.keys(): 
  print("A chave", chave, "mapeia o valor", estoque[chave]) 

chaves = list(estoque.keys()) #Não é necessariamente uma lista, então precisamos jogar para uma para utilizar 
print(estoque.keys())
print(chaves)

"""A função `values` retorna uma visão dos valores do dicionário."""

lista = ['uvas', 'bananas', 'laranjas', 'peras']

for item in lista:
  print("Valor", item) 

estoque = {'uvas': 430, 'bananas': 312, 'laranjas': 525, 'peras': 217} 

for valor in estoque.values(): 
  print("Valor: ", valor) 

valores = list(estoque.values()) #Não é necessariamente uma lista, então precisamos jogar para uma para utilizar 
print(valores)

"""A função `items` retorna a lista dos pares de chaves e valor do dicionário."""

lista = ['uvas', 'bananas', 'laranjas', 'peras']

for i, valor in enumerate(lista):
  print("O indice", i, "mapeia o valor", valor) 

estoque = {'uvas': 430, 'bananas': 312, 'laranjas': 525, 'peras': 217} 

for chave, item in estoque.items(): 
  print("A chave", chave, "mapeia o valor", item) 

items = list(estoque.items()) #Não é necessariamente uma lista, então precisamos jogar para uma para utilizar 
print(items)

"""A função `get(chave)` retorna o valor associado à uma chave, e None caso a chave não exista.

O método `get` nos permite acessar o valor associado à uma chave, semelhante ao operador `[]`. A diferença importante é que `get` não causará um erro de tempo de execução se a chave não estiver presente. Em vez disso, retornará None.
"""

estoque = {'uvas': 430, 'bananas': 312, 'laranjas': 525, 'peras': 217} 

print(estoque.get("uvas"))
print(estoque['uvas'])

print(estoque.get("goiabas"))
print(estoque['goiabas'])

print("Programa executando...")

"""A função `get(chave, alt)` retorna o valor associado à uma chave, e alt caso a chave não exista."""

estoque = {'uvas': 430, 'bananas': 312, 'laranjas': 525, 'peras': 217} 
print(estoque.get('uvas', 0)) 
print(estoque.get('cerejas', 0))
print(estoque.get('bananas', 0))
print(estoque.get('melancia', 0))

"""Podemos também utilizar as operações in e not in para verificar a existência de um item, como pode ser utilizado em uma lista também."""

estoque = {'uvas': 430, 'bananas': 312, 'laranjas': 525, 'peras': 217} 
chave = "cerejas"

if chave in estoque: 
  print(estoque[chave]) 
else: 
  print(0)

print(estoque.get(chave, 0))



"""### Mutabilidade

---

Como os dicionários são mutáveis, você precisa estar atento ao alias. Sempre que duas variáveis se referem ao mesmo objeto de dicionário, as alterações em uma afetam a outra. Por exemplo, `opostos` é um dicionário que contém pares de opostos.
"""

x = 10
y = x
print("x = ", x)
print("y = ", y)

print()

y = 5
print("x = ", x)
print("y = ", y)

print()

x = 20
print("x = ", x)
print("y = ", y)

print()

x = {'cima': 'baixo', 'direito': 'torto', 'verdadeiro': 'falso'} 
y = x
#print(y is x) 
print("x = ", x)
print("y = ", y)

print()

y['direito'] = 'esquerdo' 

print("x = ", x)
print("y = ", y)

print()

x['direito'] = 'errado' 

print("x = ", x)
print("y = ", y)

print()

x = [1, 2, 3]
y = x

print("x = ", x)
print("y = ", y)

print()

y[2] = 1
print("x = ", x)
print("y = ", y)

print()

"""Como você pode ver no operador `is`, alias e opostos se referem ao mesmo objeto. Se você deseja modificar um dicionário e manter uma cópia do original, use o método copy do dicionário. Como copia é uma cópia do dicionário, alterações nele não afetarão o original."""

x = {'cima': 'baixo', 'direito': 'torto', 'verdadeiro': 'falso'} 
y = x
#print(y is x) 
y['direito'] = 'esquerdo' 
print(x)

x = {'cima': 'baixo', 'direito': 'torto', 'verdadeiro': 'falso'} 
y = x.copy()
#print(y is x) 
y['direito'] = 'esquerdo' 
print(x)

indice = 21
chave = 7

novo_indice = (indice + chave) % 26

print(novo_indice)

chave = 4
alfabeto = "abcdefghijklmnopqrstuvwxyz"
print(len(alfabeto))
print(list(enumerate(alfabeto)))
frase = "olha que legal"
frase_nova = ""
for letra in frase:
  #verificar se a letra ta no alfabeto
  #se a letra não estiver, adiciona o caracter inalterado pra frase nova
  #se a letra estiver, pegar a letra que está no indice deslocado pela chave no alfabeta 
  print(letra)