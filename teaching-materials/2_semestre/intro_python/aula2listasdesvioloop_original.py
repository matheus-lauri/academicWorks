# -*- coding: utf-8 -*-
"""Aula2ListasDesvioLoop_Original.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13pWzU7ThpfC8NelVRV88rJtiEKrL_K13

## Listas

---

### Introdução

---

No Python, criamos listas atribuindo uma sequência de valores em sua declaração, estes valores ficam entre colchetes e separados por vírgula:
"""

x = 10
nome = "a"
lista = [1, 2 ,3]

print(5.01 - 5 == 0.01)
x = 150.01 - 150
print(x)
x = []
primos = [2, 3, 5, 7, 11]

fruta1 = 'abacaxi'
fruta2 = 'goiaba'
fruta3 = 'banana'

frutas = [fruta1, fruta2, fruta3]

print(x)
print(primos)
print(frutas)

"""Os elementos podem ser acessados, e alterados, a partir do índice de sua posição colocado dentro de colchetes no fim do nome da variável."""

frutas = ["abacaxi", "goiaba", "banana"] 


print(frutas)
print(frutas[0]) #lembrando que os índices começam com 0
print(frutas[1])
print(frutas[2])

segunda_fruta = frutas[1]
print("Segunda fruta:", segunda_fruta)

frutas[1] = "laranja"
print(frutas)

frutas = ["abacaxi", "goiaba", "banana"] 

print(frutas[3]) #erro, o índice não existe

"""As listas não precisam que todos os elementos sejam do mesmo tipo."""

frutas = ['abacaxi', 10, True] 

print(frutas)

#frutas[0] = 25 #os elementos podem ter tipos diferentes 
print(frutas)

teste = frutas[0]
teste2 = frutas[2]

print(frutas[1] + 10)

matriz = [[1,2,3],[4,5,6],[7,8,9]]
linha1 = matriz[0]
linha2 = matriz[1]
linha3 = matriz[2]
elemento1 = linha1[0]
elemento6 = matriz[1][2]
elemento8 = matriz[2][1]

print(matriz)

produtos = [['arroz', 'sal', "feijao"], [2.55, 1.28, 2.47], True]

print(produtos[0])
print(produtos[1])
print(produtos[2])

print(produtos[0][1])
print(produtos[1][1])
print(produtos[2])

"""No Python também temos os índices negativos, eles acessam os itens a partir do último, em ordem inversa, começando pelo `-1`"""

primos = [2, 3, 5, 7, 11, 13, 20, 25, 50, 75, 78, 1550, 120, 1245]

print(primos[-14])
print(primos[8])

primos = [2, 3, 5, 7, 11]

print(primos[-6]) #o acesso por números negativos também verifica o tamanho da lista

"""A função `len()` recebendo por parâmetro uma lista retorna o número de elementos contidos nela."""

lista = [1, 2, 3, 4, 5, 6, 7]
tamanho_lista = len(lista)

num = [1, 2, True, ["Oito", "Sete"]]
print(len(num))
print(len(num[3]))

letras = ["B", "H", "G"]
tamLetras = len(letras)
print(tamLetras)

"""### Adicionando Elementos

---

Para adicionar elementos no fim de uma lista, utilizamos a função `append()` associada à variável, ela espera somente um elemento e o adiciona ao fim da lista.
"""

sequencia = ["Cinco", "Seis"] 

print(len(sequencia))
print(sequencia)

sequencia.append("Sete")
print(sequencia) 
sequencia.append("Oito") 
print(sequencia)
sequencia.append([1, 2]) 
print(sequencia)
sequencia.append(True) 

print(len(sequencia))
print(sequencia)



valores = []
print(valores)

for i in range(5):

  val = int(input("Digite um valor: "))

  valores.append(val)
  print(valores)

"""Enquanto a função `insert()` espera dois parâmetros, o índice e o elemento a ser adicionado, e o insere na posição indicada na lista."""

sequencia = ["Um", "Dois", "Quatro", "Cinco", "Seis"] 
print(sequencia) 
#sequencia.append("Três")
#sequencia[2] = "Três"
sequencia.insert(2, "Três")
print(sequencia)

"""Lembrando que todos os elementos daquela da posição da variável em diante são jogados para frente."""

sequencia = ["Um", "Dois", "Três", "Quatro", "Seis"] 
print(sequencia) 
sequencia.insert(4, "Cinco") 
sequencia.insert(-1, "Sete") #podemos utilizar os índices negativos também, mas cuidado com os resultados
print(sequencia)

"""### Removendo Elementos

---

Para remover elementos de uma lista, utilizamos a função `remove()` associada à variável, ela espera  como parâmetro o elemento a ser excluído, ele remove a primeira ocorrência do elemento.
"""

sequencia = ["A", "C", "B", "C", "D", "E", "F", "E"]  
print(sequencia)

sequencia.remove("C")
print(sequencia)  

sequencia.remove("E") 
print(sequencia)

"""Caso o elemento não exista, a função `remove()` retorna um erro."""

sequencia = ["A", "C", "B", "C", "D", "E", "F", "H", "E"] 

if "H" in sequencia:
  sequencia.remove("H") 

print(sequencia)

"""Outra forma de remover um elemento é a função `pop()` associada à variável, ela espera como parâmetro o índice do elemento que será removido."""

sequencia = ["A", "B", "C", "D", "E", "F", "E"]
print(len(sequencia))
print(sequencia)
sequencia.remove("C")
print(sequencia)
sequencia.pop(-1)
print(sequencia)
sequencia.pop(0)
print(sequencia)
print(len(sequencia))

"""### Operadores `in` e `not it`

---

Os operadores `in` e `not in` são utilizados para verificar a presença, ou ausência, de um elemento em um vetor, retornando um resultado lógico, particurlamente útil para a tomada de decisões em desvios condicionais.
"""

frutas = ["abacaxi", "goiaba", "banana"] 

print("uva" in frutas)
print("banana" in frutas)
print("chocolate" not in frutas)

"""### Operações Aritméticas

---

Dois operadores aritméticos podem ser utilizados em listas: soma e multiplicação. 

A soma pode ser aplicada em duas variáveis de lista, e concatena as duas, criando um lista que é composta pelos elementos da primeira seguidos pelos da segunda.
"""

numeros = ["Um", "Dois"] 
continuacao = ["Três", "Quatro", "Cinco"]
print(numeros) 
print(continuacao)
soma1 = numeros + continuacao 
print(soma1)
soma2 = continuacao + numeros 
print(soma2)

"""A multiplicação é aplicada a partir de uma lista e um inteiro, retornando um nova lista que é a replicação dos elementos da lista original pelo número de vezes dado pelo inteiro."""

vetor = [0, 2, 4] * 10
print(vetor)

refrao = ["NAN"] 
refrao = refrao * 10
refrao.append("BATMAN")
print(refrao)

"""### Tuplas

---

Tuplas são parecidas com as listas, com a diferença de seus dados serem imutáveis (não podem ser alterados). A diferença da sintaxe é a utilização de parênteses ao invés de colchetes.
"""

listaManeira = ["O", "A"]
print(listaManeira)

tuplaDoida = ("O", "A") 
print(tuplaDoida)

tupla = (1, "texto", [1,2, 3], (1, 3))
print(tupla[1])

lista = [1, 2]
lista[1] = 4
print(lista)

tupla = (1, 2) 
tupla[1] = 4 #ERRO
print(tupla)

"""Tuplas também não possuem as funções de adicionar e remover elementos das listas."""

lista = [1, 2] 
lista.append(4)

tupla = (1, 2) 
tupla.append(4) #ERRO

"""### Listas Aninhadas

---

Os itens de uma lista também podem ser listas, com isso podemos fazer arrays de múltiplas dimensões.
"""

matriz = [[1, 2, 3], [4, 5, 6], [7, 8]] #lembrando que não é necessário que todos os itens sejam do mesmo tamanho
print(matriz)
matriz2 = [[1, 2], "Batata", True] #nem mesmo precisam ser todos listas
print(matriz2)

"""O acesso dos elementos dessas listas é feito por colchetes encadeados, começando pela posição da lista mais externa."""

matriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(matriz[1][2])
print(matriz[3][2])

"""## Desvio Condicional e Laço de Repetição

---

### Indentação e Escopo

---

Além de diferenças óbvias para outras linguagens de programação, como a falta de parênteses e chaves, também precisamos dar atenção para a indentação, onde os blocos são definidos pela quantidade de espaços de recuo antes de uma linha de comando. 

Cuidado com espaços e tabulações!
"""

for i in range(4):
  print("dentro")
print("fora")

for i in range(4):
         print("dentro")
         print("fora") 

         for i in range(4):
              print("dentro")
              print("fora") 
        
         print("for interno")
print("for externo")

"""O recuo para um novo escopo não tem um padrão único, pode ser um ou mais espaços, ou uma tabulação.

Mas existem duas regras:
  
*   Um escopo mais interno deve ter um avanço maior que o escopo externo;
*   Para voltar ao escopo anterior ele deve voltar ao mesmo recuo.
"""

num = 5
if num < 2:
     print("menor")
else:
  print("maior")

num = 45
if num < 2 :
    print("menor")
 print("acabou") #erro por não voltar à indentação correta

"""### Desvio Condicional

---

A estrutura do desvio condicional em python é a seguinte: 


```
if <condição> :
  <comando>
  <comando>
  ...
```

Onde a condição é um operação que resulta em um resultado booleano (`True` ou `False`) e os comandos são códigos normais, como um `print()`, que ficam indentados em um escopo interno ao `if`.

Caso a condição seja verdadeira, os comando dentro do escopo do `if` são executados.
"""

x = 4
#if(x == 3){
#    cout << normal;
#}

if x == 3:
  print("normal")
print("fim")

num = int(input("Digite um valor: "))
if num > 5:
  print("O número é maior que 5")

"""Lembrando que não temos chaves, o escopo é pela indentação."""

acertou = False

if acertou:
  print("Parabéns")
print("Você acertou")

acertou = False

if acertou:
  print("Parabéns")
  print("Você acertou")

"""O comando `else` pode ser utilizado como complemento à um comando de `if`. Ele fica no mesmo nível de bloco do `if` e é seguido por `:`.

Ele é executado quando a condição do `if` é falsa. E segue o seguinte padrão.

```
if <condição> :
  <comando>
  ...
else:
  <comando>
  ...
```


"""

num = 58

if num % 2 == 0:
  print("par")
else: #lembrando que o else fica sempre alinhado ao if
  print("ímpar")

"""Nada impede que tenhamos estruturas aninhadas em Python, como ocorre com outras linguagens, só devemos ter cuidado com a indentação."""

n1 = 5
n2 = 6
n3 = 8
n4 = 9
soma = n1 + n2 + n3 + n4

#notas = [5, 6, 8, 9]
#soma = sum(notas)

media = soma / 4

# Operadores relacionais
# > (maior)  
# < (menor)  
# >= (maior ou igual)  
# <= (menor ou igual)  
# == (igual)  
# != (diferente)

if media >= 6:
    print("Passou")
else:
    if (media >= 4):
        print("Ficou em Recuperação")
    else:
        print("Reprovou")
print(media)

"""A linguagem Python não possui o desvio por switch, mas possui um atalho para encadear `if` e `else`, o comando `elif`.

Ele conta com uma condição e só é chamado se a condição do `if` ou `elif` anterior é falsa. O `elif` pode ser declarado em cadeia, que pode terminar com um `else`.
"""

nota = 7.5

if nota >= 9:
  print("Conceito A")
elif nota >= 8:
  print("Conceito B")
elif nota >= 7:
  print("Conceito C")
else:
  print("Reprovado")

if nota >= 9:
  print("Conceito A")
else:
  if nota >= 8:
    print("Conceito B")
  else:
      if nota >= 7:
        print("Conceito C")
      else:
        print("Reprovado")

"""### Laço de Repetição

---

Comum em diferentes linguagens de programação, o Python também usa o comando `while` (mas não possui o comando `do..while`). Onde a cada iteração a condição é verificada e, caso ela seja verdadeira, os comandos internos são executados, depois a condição é verificada novamente, até que seja falsa.

Ele segue um formato parecido com o do `if`. 


```
while <condição> : 
  <comando> 
  <comando> 
  ...
```
"""

num = 0

while num < 5:
  print(num)
  num = num + 1  #num++(assim como) não existe
print("acabou")

num = 5
while num > 0: #cuidado com loops infinitos por conta da indentação
  print(num)
  num -= 1

"""O comando `for`, ao contrário de algumas linguages de programação, tem somente o formato parecido com o do "for each", onde itera sobre uma lista.

Ele segue o seguinte formato:



```
for <elemento> in lista: 
  <comando> 
  <comando> 
  ...
```
O "for each" é porque pode se ler como, para cada `<elemento>` na `<lista>`, fazer `<comando>`. Ele executa então os comandos dentro do seu escopo para cada elemento da lista.


"""

#for(int i = 0; i < len(numeros); i++){
#    int numero = numeros[i];
#    cout << numero;
#}


numeros = [1, 20, 3, 4, 5, 6, 7]
for num in numeros:
  print(num)

compras = ["ovos", "pão" ,"batata", "leite", "arroz", "feijão"]
#print(compras)

for item in compras:
  print("Comprar", item)

inteiros = [2, 3, 1, 5, 4, 10, 8]
tamanho = len(inteiros)

for numero in inteiros:
  dobro = numero * 2
  print(dobro)

compras = ["ovos", "pão" ,"batata", "leite", "arroz", "feijão"]
indicesDoidos = [1, 2, 0, 5, 4, 3]

for i in indicesDoidos:
  print("Comprar", compras[i])

"""A cada execução a variável antes do `in` recebe um elemento da lista, na ordem em que estão armazenados."""

numeros = [2, 5, 10, 3]
soma = 0

for n in numeros:
  print(n)
  soma = soma + n

print("A soma é", soma)

"""Para utilizarmos o `for` da forma mais conhecida, podemos utilizar a função `range()`. Ela gera uma lista de iteração com inteiros crescentes, de acordo com os parâmtros passados, tendo a seguinte assinatura:



```
range(<inicio(incluso)>, <fim(não incluso)>, <intervalo>)
```

Ela pode ser utilizada de 3 formas:

Somente com um parâmetro, ele vai indicar o fim da sequência (lembrando que ele não é incluído), começando em 0 e com o intervalo de 1. Esse é o padrão de índices de uma lista, se passarmos o tamanho dela por parâmetro.
"""

print(list(range(20)))
#for i in range(20):
#for(int i = 0; i < 20; i++)

for i in range(10):
  print("legal")

inteiros = [2, 3, 1, 5, 4]

lista = list(range(5))
print(lista)

for i in range(5):
  print(inteiros[i])

#for(int i = 0; i < 5; i++)

lista = ["A", "B", "C", "D", "R", "SD"]

tamanhoLista = len(lista)
for i in range(tamanhoLista):
  print(lista[i])

for item in lista:
  print(item)

#for(int i = 0; i < tamanhoLista; i++)

"""Podemos também utilizar 2 parâmetros, onde o primeiro é o início, esse incluído, e o segundo é o fim, o intervalo continuo sendo 1. Pode ser utilizado para utilizar somente parte de uma lista."""

print(list(range(5, 20)))
#for i in range(5, 20):
#for(int i = 5; i < 20; i++)

for n in range(4, 8):
  print(n)

#for(int n = 4; n < 8; n++)

#lista = ["A", "B", "C", "D", "E", "F"]

#for i in range(2, 5):
#  print(lista[i])


lista = [-3, -4, -50, -2, -1, -9]
maior = lista[0]
for i in range(1, len(lista)):
  if lista[i] > maior:
    maior = lista[i]

print(maior)

"""Por último, podemos utilizar a função com os 3 parâmtros, sendo o primeiro o início, o segundo o fim, e o terceiro o intervalo."""

print(list(range(5, 200, 13)))
#for i in range(5, 200, 13):
#for(int i = 5; i < 200; i+=13)
#i = i + 13
#i += 13
#i++
#i+=1
#i = i + 1

for i in range(4, 20, 2):
  print(i)

print()

#for(int i = 4; i < 20; i = i + 2)

lista = [1, 2, 4, 5, 6, 8]

for i in range(len(lista)):
  print(lista[i])

print()

for i in range(0, len(lista), 1):
  print(lista[i])

print()

print(list(range(1, -4, -1)))
#for i in for i in range(1, -4, -1)
#for(int i = 1; i > -4; i--) i = i - 1 ou i -= 1

for i in range(1, -4, -1): #podemos utilizar números negativos
  print(i)

print(list(range(1, 4, -1)))
#for(int i = 1; i < 4; i--) i = i - 1 ou i -= 1

for i in range(1, 4, -1): #mas cuidado com os valores
  print(i)

for i in range(1, 4, 0.2): #somente inteiros
  print(i)

"""### Strings

---

As `strings` no python são arrays de caracteres, como em muitas linguagens e podem ser tratados como tal. Mas o python não possui um tipo `char`, sendo que um caracter é uma `string` de tamanho 1.
"""

palavra = "Batatas"


print(palavra)

print(palavra[0])
print(palavra[-1])

#palavra[3] = "u" #uma diferença para uma lista é que não tem suporte a mudança de um item, funcionando mais como uma tupla


palavra = "Batuta"

print()
for letra in palavra:
  print(letra)

print()

for i in range(len(palavra)):
  print(palavra[i])


letra = "u"
if letra in palavra:
  print("Tem a letra", letra)
else:
  print("Não tem a letra", letra)

novastr = "legal"
palavra = ["l", "e", "g", "a", "l"]

print("leg" in novastr)
print("h" in novastr)

novalist = [10, 1, 4, 5, 8]

if(1 in novalist and 8 in novalist):
  print("Tem 1 e 8")

if(1 in novalist or 8 in novalist):
  print("Tem 1 ou 8")

"""Existem diferentes funções que específicas para se trabalhar com `string`, veremos algumas delas ao longo da disciplina, mas uma coisa que temos que ter em mente é que essas funções não alteram a variável, mas criam uma nova `string` modificada. """

palavra = "LEgal"

palavra = palavra.lower()
print(palavra)
print()

frase = "olha que legal"
lista = frase.split(" ")
print(lista)

palavra = "LEgal"

palavra.lower()
print(palavra)
print()

l_palavra = palavra.lower()
u_palavra = palavra.upper()
print(l_palavra)
print(u_palavra)
print()

palavra = palavra.replace("gal", "novo")
print(palavra)
print()

lista_s = "   O carro é azul"
print(lista_s)
lista_s = lista_s.strip()
lista = lista_s.split(" ")
print(lista_s)
print(lista)
for item in lista:
  print(item)

palavra = "                      Palavra   "
s_palavra = palavra.strip()
print(palavra)
print(s_palavra)