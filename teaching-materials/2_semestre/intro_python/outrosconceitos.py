# -*- coding: utf-8 -*-
"""OutrosConceitos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z7pCs-lL_V1_muWUfnsJuB0w79ROCbOR

## Tratamento de exceção

---

Alguns erros acontecem em tempo de execução, como tentar acessar uma posição que não existe em um vetor, converter um valor errado, ou tentar ler um arquivo que não existe.

Alguns desses erros podem fugir do controle do programador, vindo de uma entrada de usuário, por exemplo.

Para isso utilizamos os comando `try`, `except`
"""

entrada = input("Digite um inteiro: ")

entrada = int(entrada)
print("O dobro do da entrada é:", entrada * 2)

print("FIM")

entrada = input("Digite um inteiro: ")

try:
  entrada = int(entrada)
  print("O dobro do da entrada é:", entrada * 2)
except:
  print("O valor digitado não é um inteiro")

print("FIM")

entrada = input("Digite um inteiro: ")
inteiro = False

try:
  entrada = int(entrada)
  print("Esse valor é um inteiro")
  inteiro = True
except:
  print("Esse valor não é um inteiro")

while inteiro == False:
  entrada = input("Digite um inteiro: ")
  try:
    entrada = int(entrada)
    print("Esse valor é um inteiro")
    inteiro = True
  except:
    print("Esse valor não é um inteiro")

"""Também podemos especificar o tipo do erro."""

lista = ["a", "b", "c", "d"]
entrada = input("Digite um indice: ")
entrada = int(entrada)
print("O valor na lista é:", lista[entrada])

lista = ["a", "b", "c", "d"]
entrada = input("Digite um indice: ")

try:
  entrada = int(entrada)
  print("O valor na lista é:", lista[entrada])
except:
  print("Erro")

lista = [2, 3, 5, 2]
entrada = input("Digite um indice: ")

try:
  entrada = int(entrada)
  print("O valor na lista é:", lista[entrada])
except ValueError as e:
  print("Esse valor não é um inteiro")
except IndexError as e:
  print("Índice inválido")

"""## Parâmetros da função `print`

---

O parâmetro `end` substitui o padrão de fim de um `print`, que é a quebra de linha
"""

def funcao(a, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, end="\n", sep=" "):
  print("sdasd")

funcao(10, 0, 0, 0, 0, 0, 0, 0, 0, 10)
funcao(10, j=10)

print('O Quadrado dos números de 1 a 10:')
for i in range(1, 10):
  print(i ** 2)

print("O Quandrado dos números de 1 a 10:", end="\n --------- \n")
for i in range(1, 10):
  print(i ** 2, end="\n --------- \n")

print("a", "b", "c", end="-/-", sep="-/-")
print("d", "e", "f", end="", sep="-/-")

"""O parâmetro `sep` substitui o padrão de fim de um `print`, que é o espaço"""

dia = 32
mes = 12
ano = 2020
print(dia, mes, ano)

dia = 32
mes = 12
ano = 2020
print(dia, mes, ano, sep="/")

"""## Retorno de Multiplas variáveis

---

O Python possui uma forma um pouco mais livre para tratar o retorno de múltiplas variáveis, se comparado a outras linguagens de programação.

Podemos ter o retorno a partir de uma lista.
"""

def funcao():
  x = 10
  y = "Batata"
  return [x, y]

lista = funcao()
print(lista[0])
print(lista[1])

"""Ou de um dicionário."""

def funcao():
  x = 10
  y = "Batata"
  return {"x": x, "y": y}

dic = funcao()
print(dic["x"])
print(dic["y"])

"""Mas o uso de tuplas, de forma explicita ou não, faz a forma de retorno mais interessante, permitindo a separação direta dos valores."""

def func():
  return 10, 15
 
x, y = func()
print(x)
print(y)

def funcao():
  x = 10
  y = "Batata"
  return x, y

tupla = funcao();
print(tupla)

fx, fy = funcao()
print(fx)
print(fy)

a = "A"
b = "B"

print(a, b, sep=" - ")

a, b = b, a



print(a, b, sep=" - ")

lista = ["a", "b", "c", "d", "e"]

for item in lista:
  print(item)

print()

for indice in range(len(lista)):
  print(indice)

print()

for indice, item in enumerate(lista):
  print(indice, item)

a = "var1"
b = "var2"

print("A:", a, "B:", b)

a, b = b, a

print("A:", a, "B:", b)

lista = ["A", "B", "D", "H"]

for item in lista:
  print(item)

print("\n")

for i in range(len(lista)):
  print(lista[i])

print("\n")

for _, i in enumerate(lista):
  print(i)

def func():
  return 10, 5, 15

x, y, z = func()
tupla = func()
_, x, _ = func()

"""## Comando `yield`

---

Além do `return`, existe o comando `yield` em Python. Ele não finaliza a função totalmente, ele para e retorna o valor, mas mantém os estados das variáveis e permite retomar a execução.
"""

lista = [1, 2, 3, 5]
print(list(enumerate(lista)))

def rangeN(fim):
  lista = []
  cont = 0
  while cont < fim:
    lista.append(cont)
    cont = cont + 1
  
  return lista

print(rangeN(10))

def OlaMundo():
  print("Olá Mundo")

OlaMundo()
OlaMundo()
OlaMundo()
OlaMundo()

def rangeN(fim):
  cont = 0
  while cont < fim:
    yield cont
    cont = cont + 1

for i in rangeN(10):
  print(i)

print(list(rangeN(10)))
print(list(range(10)))

def enumerateN(lista):
  cont = 0
  while cont < len(lista):
    yield cont, lista[cont]
    cont = cont + 1

lista = ["A", "O", "I", "J", "B", "E", "C", "D"]
print(list(enumerate(lista)))
print(list(enumerateN(lista)))

for indice, item in enumerateN(lista):
  print(indice, "é", item)

def top():
  x = 2
  yield x
  x = x + 4
  yield x
  x = 25
  yield x


for i in top():
  print(i)

def top():
  x = 2
  yield x
  x = x + 4
  yield x
  x = 25
  yield x

valor = top()
print(valor)
print(next(valor))
print(next(valor))
print(next(valor))

def nossoRange(valor):
  cont = 0
  while cont < valor:
    yield cont
    cont += 1

def nossoEnumerate(lista):
  cont = 0
  while cont < len(lista):
    yield cont, lista[cont]
    cont += 1

lista = [2, 3, 12, 14, 20]

for i, elemento in nossoEnumerate(lista):
  print(i, end="-")
  print(elemento)

def top():
  x = 2
  yield x
  x = x + 4
  yield x
  x = 25
  yield x

for texto in top():
  print(texto, end=" ")

"""Ele é normalmente utilizado para gerar uma iteração por valores."""

def quadrados(lista):
  for item in lista:
    yield item ** 2

lista = [2, 5, 7, 9, 10]

for item in quadrados(lista):
  print(item)

"""## Comandos em laço de repetição

---

O comando `break` finaliza o laço de repetição.
"""

while(2 == 2):
  nota = float(input("Digita uma nota:"))
  if nota < 0:
    break
  if nota >= 6:
    print("Passou")

for letra in "chocolate":
  print(letra, end="")
  if letra == 't':
    break

"""O comando `continue` pula o laço de repetição para a próxima iteração."""

lista = [1, 2, 4, 3, 15, 6, 8]
for item in lista:
  print("Número:", item)
  if item % 2 == 0:
    continue
  print("Número Ímpar")

"""O comando `pass` serve para fazer um laço vazio, quando não se sabe ainda o que será colocado nele, ele também serve para funções e desvios condicionais."""

def funcaoNova():
  pass

print("adas")

print("legal")

listop = [2, 4.4, "Batata", False]

for i in listop:
  pass#não sei o que fazer ainda

def decifrarCifraDeCesar():
  pass

"""Diferente de outras linguagens de programação, o python possui o comando  `else` para o laço de repetição `for`. Ele é chamado quando nenhuma vez `break` é chamado, e o laço termina normalmente."""

letra = "c"
palavra = "chocolate"

temLetra = False

for l in palavra:
  if l == letra:
    temLetra = True
    break

if temLetra == False:
  print("Não tem", letra)
else:
  print("Tem", letra)

letra = "x"
palavra = "chocolate"
for l in palavra:
  if l == letra:
    print("Tem", letra)
    break
else:
  print("Não tem", letra)

def funcao():
  letra = "t"
palavra = "chocolate"
for l in palavra:
  if l == letra:
    print("Tem", letra)
    return

  print("Não tem", letra)

"""O comando `enumerate` é uma abordagem interessante, quando se precisa trabalhar com o item da lista e seu índice, sem precisar fazer o acesso de cada elemento pela lista e nem gerar um função `range()` pelo tamanho da lista."""

listaDeNumerosImportantes = [2, 1, 5, 7, 4, 3]

for item in listaDeNumerosImportantes:
  print("O item é", item)

listaDeNumerosImportantes = [2, 1, 5, 7, 4, 3]

for i in range(len(listaDeNumerosImportantes)):
  print("O item", i, "da lista é", listaDeNumerosImportantes[i])

listaDeNumerosImportantes = [2, 1, 5, 7, 4, 3]

for i, item in enumerate(listaDeNumerosImportantes):
  print("O item", i, "da lista é", item)

"""## Operadores in, not in, is e is not

---

Os operadores `in` e `not in` servem para verificar a existência (ou não) de um elemento em uma lista.
"""

palavra = "batata"
letra = "ata"

if letra in palavra:
  print("Tem", letra)

vetor = [8, 4, 5, 6]
numero = 1

if numero not in vetor:
  print("Não tem o número", numero)

if numero in vetor:
  print("Tem o número", numero)

dici = {"a" : "certo", "b" : "errado"}

if "a" in dici:
  print("Tem")
else:
  print("Não tem")

"""Os operadores `is` e `is not` funcionam de forma parecida com o operador de igualdade, mas eles verificam se o objeto é o mesmo, e não os valores."""

lista1 = [2, 4, 5, 6]
lista2 = [2, 4, 5, 6]

print("Lista1 =", lista1)
print("Lista2 =", lista2)
print("==", lista1 == lista2)
print("is", lista1 is lista2)
lista2[2] = 500
print("Lista1 =", lista1)
print("Lista2 =", lista2)
print("==", lista1 == lista2)
print("is", lista1 is lista2)



print("")

lista2 = lista1

print("Lista1 =", lista1)
print("Lista2 =", lista2)
print("==", lista1 == lista2)
print("is", lista1 is lista2)
lista2[2] = 500 
print("Lista1 =", lista1)
print("Lista2 =", lista2)
print("==", lista1 == lista2)
print("is", lista1 is lista2)

lista1 = [1, 2, 3]
lista2 = lista1
lista3 = lista1.copy()
print()
print("==", lista1 == lista2)
print("==", lista1 == lista3)
print()
print("is", lista1 is lista2)
print("is", lista1 is lista3)